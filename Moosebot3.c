#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  flyEnc,         sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           intake,        tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           lDrive,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           otlFly,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           oblFly,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           ilFly,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           otrFly,        tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port7,           obrFly,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           irFly,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           rDrive,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          lift,          tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "rkUtil/lib.h"

#define RKCOMP_LCD

#include "rkCompetition/lib.h"

#include "rkControl/base.h"
#include "rkControl/diff.h"
#include "rkControl/tbh.h"
#include "rkControl/tbhController.h"

#include "rkLcd/lib.h"

#include "rkLogic/dlatch.h"

ADiff flyDiff, fly2Diff;
Tbh flyTbh;
TbhController flyCtl;

float flyLRPwr = 800,
	flySRPwr = 500;

void startFlyTbh(bool useCtl) {
	resetDiff(&flyDiff, SensorValue[flyEnc]);
	resetDiff(&fly2Diff, flyDiff.out);

	if (useCtl) updateTbhController(flyCtl, 0);
	else setTbhDoRun(&flyTbh, true);

	startCtlLoop();
}

void stopAllCtls() {
	setTbhDoRun(&flyTbh, false);

	startCtlLoop();
}

task lcd() {
	while (true) {
		string str;
		bLCDBacklight = true;
		clearLCD();

		if (flyTbh.doRun) {
			sprintf(str, "%.2f", flyTbh.out);
			displayLCDCenteredString(0, str);
		}

		sprintf(str, "%d", flyLRPwr);
		displayLCDCenteredString(1, str);

		if ((nLCDButtons & kButtonLeft) != (nLCDButtons & kButtonRight)) {
			if (nLCDButtons & kButtonRight) flyLRPwr += 5;
			else flyLRPwr -= 5;

			wait1Msec(50);
		}

		wait1Msec(50);
	}
}

void init() {
	initTbh(&flyTbh, 5, .25, .15, 127, true);
	initTbhController(&flyCtl, &flyTbh, false);

	ctlLoopInterval = 50;
}

void updateCtl(float dt) {
	if (flyTbh.doUpdate) {
		updateDiff(&flyDiff, SensorValue[flyEnc], dt);
		updateDiff(&fly2Diff, flyDiff.out, dt);

		motor[otlFly] = motor[oblFly] = motor[ilFly] =
			motor[otrFly] = motor[obrFly] = motor[irFly] =
			updateTbh(&flyTbh, flyDiff.out, fly2Diff.out, dt);
	}
}

task auton() { }

void endAuton() { }

task userOp() {
	DLatch flyLRLatch, flySRLatch;
	float flyPwr;
	word flyDir = 0;

	resetDLatch(&flyLRLatch, 0);
	resetDLatch(&flySRLatch, 0);

	startFlyTbh(true);

	while (true) {
		word driveX = vexRT[ChLX],
			driveY = vexRT[ChRY];

		motor[lDrive] = arcadeLeft(driveX, driveY);
		motor[rDrive] = arcadeRight(driveX, driveY);

		motor[intake] = motor[lift] =
			joyDigi2(Btn6U, 127, Btn6D, -127);

		if (risingEdge(&flyLRLatch, vexRT[Btn5U]) !=
			risingEdge(&flySRLatch, vexRT[Btn5D])) {

			if (flyLRLatch.out) flyDir = flyDir == 1 ? 0 : 1;
			else flyDir = flyDir == 2 ? 0 : 2;
		}

		switch (flyDir) {
		case 1:
			flyPwr = flyLRPwr;
			break;
		case 2:
			flyPwr = flySRPwr;
			break;
		default:
			flyPwr = 0;
			break;
		}

		updateTbhController(&flyCtl, flyPwr);
	}
}

void endUserOp() {
	stopAllCtls();
}

#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(Sensor, dgtl1,  flyEnc,         sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  redLed,         sensorLEDtoVCC)
#pragma config(Sensor, dgtl4,  yellowLed,      sensorLEDtoVCC)
#pragma config(Sensor, dgtl5,  greenLed,       sensorLEDtoVCC)
#pragma config(Motor,  port1,           intake,        tmotorVex393TurboSpeed_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           blWheel,       tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           flWheel,       tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           brWheel,       tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           frWheel,       tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           blFly,         tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           tlFly,         tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           brFly,         tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port9,           trFly,         tmotorVex393TurboSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          lift,          tmotorVex393TurboSpeed_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define RKCOMP_LCD

#include "rkUtil/lib.h";

#include "rkLogic/dlatch.h";

#include "rkControl/base.h";
#include "rkControl/diff.h";
#include "rkControl/rollAvg.h";
#include "rkControl/tbh.h";
#include "rkControl/tbhController.h";

#include "rkLcd/lib.h";

#include "rkCompetition/lib.h";

Diff flyDiff, fly2Diff;
RAFlt flyDispFlt, fly2Flt;
Tbh flyTbh;
TbhController flyTbhController;

const int dispFltLen = 10,
  fly2FltLen = 5;

float flyDispFltBuf[dispFltLen],
  fly2FltBuf[fly2FltLen];

task lcd() {
	const float flyPwrIncrement = 5;
	const word battThresh = 7800;
	const long pwrBtnsDelayInterval = 250,
		pwrBtnsRepeatInterval = 100,
		dispPwrTimeout = 1000;

	bool dispPwr = false,
		doUseLRPwr = true,
		flash = false,
		flashLeds,
		forceBattWarning = true,
		pwrBtnsDown,
		pwrBtnsDelayed,
		pwrBtnsRepeating;

	float pwrBtns;
	long time = nSysTime, flashTs = time, dispPwrTs = time, pwrBtnTs = time;
	string str;

	DLatch dismissWarningLatch, pwrBtnLatch;

	while (true) {
		time = nSysTime;

		if (nImmediateBatteryLevel < battThresh) {
			if ((time - flashTs) >= 500) {
				flash = !flash;
				flashTs = time;
			}

			flashLeds = true;
		}
		else {
			SensorValue[redLed] =
				SensorValue[yellowLed] =
				SensorValue[greenLed] = 0;
		}

		clearLCD();

		if (nLCDButtons & kButtonCenter) {
			bLCDBacklight = true;

			displayLCDCenteredString(0, "Battery:");

			sprintBatt(str);

			displayLCDString(1, 0, str);
		}
		else if (nImmediateBatteryLevel < battThresh && (rkBotDisabled || rkAutonMode || forceBattWarning)) {
			bLCDBacklight = flash;

			if (flash) displayLCDCenteredString(0, "BATTERY WARNING");

			sprintBatt(str);
			displayLCDString(1, 0, str);

			if (fallingEdge(&dismissWarningLatch, nLCDButtons || (abs(vexRT[AccelY]) > 63))) forceBattWarning = false;
		}
		else if (rkBotDisabled) {
			bLCDBacklight = false;

			displayLCDCenteredString(0, "Moosebot Mk. III");
			displayLCDCenteredString(1, "4800Buckets");
		}
		else if (rkAutonMode) {
			bLCDBacklight = true;

			displayLCDCenteredString(0, "BUCKETS MODE");
			displayLCDCenteredString(1, "ENGAGED");
		}
		else { //User op mode
			bLCDBacklight = true;

			pwrBtnsDown = PWR_BTN_DOWN ^ PWR_BTN_UP;
			risingEdge(&pwrBtnLatch, pwrBtnsDown);

			if ((pwrBtnsDown || FLY_BTNS) && flyDir) dispPwrTs = time;

			if (pwrBtnsDown && FLY_BTNS) {
				dispPwrTs = time;

				if (pwrBtnLatch.out || (time - pwrBtnTs >= (pwrBtnsRepeating ? pwrBtnsRepeatInterval : pwrBtnsDelayInterval))) {
					pwrBtnTs = time;

					if (pwrBtnsDelayed) {
					  if (!pwrBtnsRepeating) pwrBtnsRepeating = true;
					}
					else pwrBtnsDelayed = true;

					pwrBtns = twoWay(PWR_BTN_DOWN, -flyPwrIncrement, PWR_BTN_UP, flyPwrIncrement);

					if (flyDir != 0)
						flyPwr[flyDir] += pwrBtns;
				}
			}
			else pwrBtnsDelayed = pwrBtnsRepeating = false;

			if (time - dispPwrTs <= dispPwrTimeout && flyDir) {
				displayLCDCenteredString(0, flyPwrNames[flyDir]);
				displayLCDNumber(1, 0, flyPwr[flyDir]);
			}
			else if (flyTbh.doRun) {
				sprintf(str, "% 07.2f  % 07.2f",
					fmaxf(-999.99, fminf(999.99, flyDispFlt.out)),
					fmaxf(-999.99, fminf(999.99, flyTbh.err)));
				displayLCDString(0, 0, str);

				sprintf(str, "% 07.2f  % 07.2f",
					fmaxf(-999.99, fminf(999.99, fly2Flt.out)),
					fmaxf(-999.99, fminf(999.99, flyTbh.out)));
				displayLCDString(1, 0, str);

				flashLeds = false;

				SensorValue[redLed] =
					SensorValue[yellowLed] =
					SensorValue[greenLed] = 0;

				if (isTbhInThresh(&flyTbh, velThresh)) {
					if (isTbhDerivInThresh(&flyTbh, accelThresh)) SensorValue[greenLed] = 1;
					else  SensorValue[yellowLed] = 1;
				}
				else SensorValue[redLed] = 1;
			}
			else {
				sprintf(str, "%-8s%8s", "Speed", "Error");
				displayLCDString(0, 0, str);

				sprintf(str, "%-8s%8s", "Accel", "Out");
				displayLCDString(1, 0, str);
			}
		}

		if (flashLeds) {
			SensorValue[redLed] =
				SensorValue[yellowLed] =
				SensorValue[greenLed] = flash;
		}

		wait1Msec(20);
	}
}

void startFlyCtl() {
  SensorValue[flyEnc] = 0;

  resetDiff(&flyDiff, SensorValue[flyEnc] / 2);
  resetDiff(&fly2Diff, 0);

  resetRAFlt(&flyDispFlt, 0);
  resetRAFlt(&fly2Flt, 0);

  resetTbh(&flyTbh, 0);
  setTbhDoRun(&flyTbh, true);
}

void init() {
  initRAFlt(&flyDispFlt, flyDispFltBuf, dispFltLen);
  initRAFlt(&fly2Flt, fly2FltBuf, fly2FltLen);

  initTbh(&flyTbh, 0, .07, .01, .02, 127, true);

  initTbhController(&flyTbhController, &flyTbh, true);

  ctlLoopInterval = 50;
}

void updateCtl(float dt) {
  updateDiff(&flyDiff, SensorValue[flyEnc], dt);
  updateDiff(&fly2Diff, flyDiff.out, dt);

  updateRAFlt(&fly2Flt, fly2Diff.out);

  if (flyTbh.doUpdate) {
    motor[blFly] = motor[tlFly] =
    motor[brFly] = motor[trFly] =
      updateTbh(&flyTbh, flyDiff.out, fly2Diff.out, dt);
  }
}

task auton() { startCtlLoop(); }

void endAuton() { stopCtlLoop(); }

task userOp() {
  startFlyCtl();
  startCtlLoop();

  while (true) {
    motor[intake] = motor[lift] = joyAnalog(ChRY, 10);

    word flySpd = joyAnalog(ChLY, 10);

    updateTbhController(&flyTbhController, fabs(flySpd) * 3000 / 127);

    EndTimeSlice();
  }
}

void endUserOp() { stopCtlLoop(); }

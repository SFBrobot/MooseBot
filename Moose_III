#pragma config(UART_Usage, UART1, uartVEXLCD, baudRate19200, IOPins, None, None)
#pragma config(UART_Usage, UART2, uartNotUsed, baudRate4800, IOPins, None, None)
#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, I2C_1,  flyEnc,         sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           roller,        tmotorVex393TurboSpeed_HBridge, openLoop)
#pragma config(Motor,  port2,           flDrive,       tmotorVex393HighSpeed_MC29, openLoop, reversed, driveLeft)
#pragma config(Motor,  port3,           mlDrive,       tmotorVex393HighSpeed_MC29, openLoop, reversed, driveLeft)
#pragma config(Motor,  port4,           blDrive,       tmotorVex393TurboSpeed_MC29, openLoop, reversed, driveLeft)
#pragma config(Motor,  port5,           lFly,          tmotorVex393TurboSpeed_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port6,           rFly,          tmotorVex393TurboSpeed_MC29, openLoop)
#pragma config(Motor,  port7,           brDrive,       tmotorVex393TurboSpeed_MC29, openLoop, driveRight)
#pragma config(Motor,  port8,           mrDrive,       tmotorVex393HighSpeed_MC29, openLoop, driveRight)
#pragma config(Motor,  port9,           frDrive,       tmotorVex393HighSpeed_MC29, openLoop, driveRight)
#pragma config(Motor,  port10,          lift,          tmotorVex393TurboSpeed_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "rkUtil/lib.h"

#define RKCOMP_LCD

#include "rkCompetition/lib.h"

#include "rkControl/base.h"
#include "rkControl/diff.h"
#include "rkControl/tbh.h"
#include "rkControl/tbhController.h"

#include "rkLcd/lib.h"

#include "rkLogic/dlatch.h"

ADiff flyDiff, fly2Diff;
Tbh flyTbh;
TbhController flyCtl;

float flyLRPwr = 850,
	flyMRPwr = 700,
	flySRPwr = 500;

void startFlyTbh(bool useCtl) {
	resetDiff(&flyDiff, -SensorValue[flyEnc]);
	resetDiff(&fly2Diff, flyDiff.out);

	if (useCtl) updateTbhController(flyCtl, 0);
	else setTbhDoRun(&flyTbh, true);

	startCtlLoop();
}

void stopAllCtls() {
	setTbhDoRun(&flyTbh, false);

	startCtlLoop();
}

task lcd() {
	while (true) {
		string str;
		bLCDBacklight = true;
		clearLCD();

		if (flyTbh.doRun) {
			sprintf(str, "%2.1f | %.2f", flyTbh.err, flyTbh.out);
			displayLCDCenteredString(0, str);
		}

		sprintf(str, "%d", flyLRPwr);
		displayLCDCenteredString(1, str);

		if ((nLCDButtons & kButtonLeft) != (nLCDButtons & kButtonRight)) {
			if (nLCDButtons & kButtonRight) flyLRPwr += 5;
			else flyLRPwr -= 5;

			wait1Msec(50);
		}

		wait1Msec(50);
	}
}

void init() {
	initTbh(&flyTbh, 5, .25, .15, 127, true);
	initTbhController(&flyCtl, &flyTbh, false);

	ctlLoopInterval = 50;
}

void updateCtl(float dt) {
	if (flyTbh.doUpdate) {
		updateDiff(&flyDiff, -SensorValue[flyEnc], dt);
		updateDiff(&fly2Diff, flyDiff.out, dt);

		motor[lFly] =
			motor[rFly] =
			updateTbh(&flyTbh, flyDiff.out, fly2Diff.out, dt);
	}
}

task auton() { }

void endAuton() { }

task userOp() {
	DLatch flyLRLatch, flySRLatch;
	float flyPwr;
	word flyDir = 0;

	resetDLatch(&flyLRLatch, 0);
	resetDLatch(&flySRLatch, 0);

	startFlyTbh(true);

	while (true) {
		word driveX = vexRT[ChRX],
			driveY = vexRT[ChLY];

		motor[flDrive] =
			motor[mlDrive] =
			motor[blDrive] =
			arcadeLeft(driveX, driveY);

		motor[frDrive] =
			motor[mrDrive] =
			motor[brDrive] =
			arcadeRight(driveX, driveY);

		motor[roller] = motor[lift] =
			joyDigi2(Btn6U, 127, Btn6D, -127);

		//if (risingEdge(&flyLRLatch, vexRT[Btn5U]) !=
		//	risingEdge(&flySRLatch, vexRT[Btn5D])) {

		//	if (flyLRLatch.out) flyDir = flyDir == 1 ? 0 : 1;
		//	else if(flySRLatch.out) flyDir = flyDir == 2 ? 0 : 2;
		//}
			
		if(risingEdge(&flyLRLatch, vexRT[Btn5U]))
			flyDir++;
		if(flyDir > 3)
			flyDir = 0;

		switch (flyDir) {
		case 1:
			flyPwr = flyLRPwr;
			break;
		case 2:
			flyPwr = flyMRPwr;
			break;
		case 3:
			flyPwr = flySRPwr;
		default:
			flyPwr = 0;
			break;
		}

		updateTbhController(&flyCtl, flyPwr);
	}
}

void endUserOp() {
	stopAllCtls();
}
